// Copyright (C) 1998-2004 LightSys Technology Services, Inc.
//
// You may use these files and this library under the terms of the
// GNU Lesser General Public License, Version 2.1, contained in the
// included file "COPYING" or http://www.gnu.org/licenses/lgpl.txt.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.

// client-side interface module

// GLOBALS

var IFC=    {	Layer: null,
		BaseDir: "",
		Categories: new Array(),
		Definitions: new Array(),
		Loading: new Object(),
		Callbacks: new Object(),
		Params: new Object(),
		Handles: new Array()
	    };


function IfcDefinition(path, type)
    {
	this.Path = path;
	this.Type = type;
	this.MajorVersions = new Array();
	this.DEFINITION = true;
    }

// ifc_internal_LoadFinished - callback function, called when an interface def
// has been loaded from the server, and is ready for parsing
function ifc_internal_LoadFinished()
    {
    var tokens;
    var i, maj_v_num, min_v_num;
    var def;
    var def_ref;

	// get the tokens array
	if (IFC.Layer.document) tokens = IFC.Layer.document.links;
	else tokens = IFC.Layer.links;

	def_ref = tokens[tokens.length-1].pathname;
	delete IFC.Loading[def_ref];
	// see if there was an error
	if (tokens.length == 0 || tokens[tokens.length-1].target != "OK")
	    {
	    pg_debug("IFC: Error loading interface from server: ");
	    if (tokens.length > 0) pg_debug(tokens[tokens.length-1].target);
		pg_debug("\n");
	    return;
	    }
	
	pg_debug("IFC: Loaded '"+def_ref+"'interface successfully\n");

	// now start parsing the structure
	i=0;
	def = new IfcDefinition(def_ref, tokens[tokens.length-1].name);
	while (i < tokens.length - 2)
	    {
	    // first tag should be a start tag w/ major and minor version numbers
	    if (tokens[i].target != "start")
		{
		pg_debug("IFC: Expected a major version start tag. Text was '"+tokens[i].target+"'\n");
		return;
		}
	    maj_v_num = parseInt(tokens[i].host.substr(1, tokens[i].host.length-1));
	    if (isNaN(maj_v_num))
		{
		pg_debug("IFC: Invalid major version number '"+tokens[i].host+"'\n");
		return;
		}
	    pg_debug("IFC: Processing major version "+maj_v_num+"\n");
	    i++;    // next tag

	    def.MajorVersions[maj_v_num] = new Array();

	    // process each minor version
	    while (tokens[i].target != "end")
		{
		prop = 0;
		if (tokens[i].target != "start")
		    {
		    pg_debug("IFC: Expected a minor version start tag. Text was '"+tokens[i].target+"'\n");
		    return;
		    }
		min_v_num = parseInt(tokens[i].host.substr(1, tokens[i].host.length-1));
		if (isNaN(min_v_num))
		    {
		    pg_debug("IFC: Invalid minor version number '"+tokens[i].host+"'\n");
		    return;
		    }
		pg_debug("IFC:   Processing minor version "+min_v_num+"\n");
		i++;	// next tag

		def.MajorVersions[maj_v_num][min_v_num] = new Object();
		def.MajorVersions[maj_v_num][min_v_num].HANDLE = true;

		// process each category
		while (tokens[i].target != "end")
		    {
		    pg_debug("IFC:     Processing category '"+tokens[i].host+"'\n");
		    if (tokens[i].target != "end")
			{
			cat = tokens[i].host;
			def.MajorVersions[maj_v_num][min_v_num][cat] = new Object();
			pg_debug(maj_v_num+"."+min_v_num+" "+cat+"\n");
			}
		    i++;
		    // process each property
		    while (tokens[i].target != "end")
			{
			pg_debug("IFC:       Processing property '"+tokens[i].host+"'\n");

			// create the properties object via the inline object instantiation generated by the server
			eval("def.MajorVersions[maj_v_num][min_v_num][cat][tokens[i].host] = "+tokens[i].text);
			i++;
			}
		    i++;
		    }
		i++;	// next tag
		}
	    i++;    // next tag
	    }
	pg_debug("IFC: Done parsing interface definition\n");
	IFC.Definitions[def_ref] = def;
	if (IFC.Callbacks[def_ref] != null) IFC.Callbacks[def_ref](IFC.Params[def_ref]);
	delete IFC.Callbacks[def_ref];
	delete IFC.Params[def_ref];
    }


// ifcLoadDef - instructs the interface module to load an interface
// definition from the server. handles will not be retrievable from
// that definition until it has completed loading
function ifcLoadDef(def_str, func)
    {
	// make sure the path is an absolute reference
	if (def_str[0] != '/') def_str = IFC.BaseDir+"/"+def_str;

	// check to see if it's already been loaded
	if (typeof IFC.Definitions[def_str] != "undefined")
	    {
	    pg_debug("IFC: '"+def_str+"' has already been loaded\n");
	    return;
	    }
	
	// check to see if it's currently loading
	if (typeof IFC.Loading[def_str] != "undefined")
	    {
	    pg_debug("IFC: already loading '"+def_str+"'\n");
	    return;
	    }

	// specify this def as 'loading'
	IFC.Loading[def_str] = true;
	IFC.Callbacks[def_str] = func;

	// now we can start the load
	pg_debug("ifcLoadDef("+def_str+") - starting load\n");
	pg_serialized_load(IFC.Layer, def_str, ifc_internal_LoadFinished);
    }


// ifcGetHandle - retrieves a handle to an interface 
function ifcGetHandle(ifc_str)
    {
    var maj_v_num, min_v_num;
    var path, ver, tmp;
    var def;
    var handle;
    var i, j;
    var cat, member;

	// unpack the major and minor version numbers
	tmp = ifc_str.split('?');
	if (tmp.length != 2)
	    {
	    pg_debug("IFC: in ifcGetHandle, '"+ifc_str+"' is not a valid interface reference\n");
	    return null;
	    }
	path = tmp[0];
	ver = tmp.split(/[.=]/);
	if (ver.length != 3 || ver[0] != 'cx__version')
	    {
	    pg_debug("IFC: in ifcGetHandle, '"+ifc_str+"' has misformatted version\n");
	    return null;
	    }
	maj_v_num = parseInt(ver[1]);
	min_v_num = parseInt(ver[2]);
	if (isNaN(maj_v_num) || isNaN(min_v_num))
	if (ver.length != 3 || ver[0] != 'cx__version')
	    {
	    pg_debug("IFC: in ifcGetHandle, '"+ifc_str+"' has misformatted version number\n");
	    return null;
	    }

	// make sure the path is absolute
	if (path[0] != '/') path = IFC.BaseDir+"/"+path;

	// look up the interface definition
	if ( (def = IFC.Definitions[path]) == null)
	    {
	    pg_debug("IFC: couldn't find interface definition '"+path+"'\n");
	    return null;
	    }

	// build the handle
	return def[maj_v_num][min_v_num];
    }

function ifcInitialize(ifc_base_dir)
    {
	// assign the layer, browser-independently
	// FIXME FIXME This probably isn't such a hot way to do things FIXME FIXME
	if (document.getElementById) IFC.Layer = document.getElementById('ifc_layer');
	else if (document.all) IFC.Layer = document.all['ifc_layer'];
	else if (document.layers) IFC.Layer = document.layers['ifc_layer'];

	IFC.BaseDir = ifc_base_dir;
    }



// The following are routines for internal interfaces within the javascript
// client widgets

function ClientInterface(obj, i)
    {
    i.call(this);
    this.obj = obj;
    }

function ifc_init_widget(w)
    {
    w.__ifc = new Array();
    w.ifcProbe = ifc_probe;
    w.ifcProbeAdd = ifc_probe_add;
    return;
    }

function ifc_probe_add(i)
    {
    if (typeof i.name != 'undefined')
	var nm = i.name;
    else
	var nm = i.toString().substr(9,100).split('(')[0];
    if (!this.ifcProbe(i))
	this.__ifc[nm] = new ClientInterface(this,i);
    return this.__ifc[nm];
    }

function ifc_probe(i)
    {
    if (typeof i.name != 'undefined')
	var nm = i.name;
    else
	var nm = i.toString().substr(9,100).split('(')[0];
    if (this.__ifc[nm]) 
	return this.__ifc[nm];
    else
	return null;
    }


// the Action interface - allows outside objects to invoke actions
// on a given widget.
//
function ifAction()
    {
    function ifaction_invoke(a,ap)
	{
	if (this.Actions[a]) 
	    return this.Actions[a].call(this.obj, ap);
	else if (pg_diag)
	    alert("Invoke action: " + this.obj.id + " does not implement action " + a);
	return null;
	}
    function ifaction_schedinvoke(a,ap,d)
	{
	if (this.Actions[a])
	    {
	    pg_addsched_fn(this, "Invoke", [a, ap], d);
	    }
	else
	    {
	    alert("SchedInvoke action: " + this.obj.id + " does not implement action " + a);
	    }
	}
    function ifaction_add(a, f)
	{
	this.Actions[a] = f;
	}
    function ifaction_exists(a)
	{
	return (this.Actions[a])?true:false;
	}
    this.Actions = new Array();
    this.Add = ifaction_add;
    this.Exists = ifaction_exists;
    this.Invoke = ifaction_invoke;
    this.SchedInvoke = ifaction_schedinvoke;
    }


// Event interface - allows outside objects to hook into events which
// occur on the widget.
//
function ifEvent()
    {
    function ifevent_add(e)
	{
	this.Events[e] = new Array();
	}
    function ifevent_clear(e)
	{
	if (this.Events[e])
	    this.Events[e] = new Array();
	else if (pg_diag)
	    alert("Clear events: " + this.obj.id + " does not implement event " + e);
	}
    function ifevent_hook(e,f)
	{
	if (this.Events[e])
	    {
	    eo = {fn:f, name:e};
	    eo.eo = this.obj;
	    this.Events[e].push(eo);
	    }
	else if (pg_diag)
	    alert("Hook event: " + this.obj.id + " does not implement event " + e);
	}
    function ifevent_activate(e,ep)
	{
	var rval = null;
	if (this.Events[e])
	    {
	    for(var ev=0; ev<this.Events[e].length;ev++)
		{
		rval = this.Events[e][ev].fn.call(this.Events[e][ev].eo, ep);
		/*if ((this.Events[e][ev]).fn == ifevent_connect_exec)
		    {
		    rval = (this.Events[e][ev]).fn(ep);
		    }
		else
		    {
		    rval = (this.Events[e][ev]).fn.call(this.obj, ep);
		    }*/
		}
	    }
	else if (pg_diag)
	    {
	    alert("Activate event: " + this.obj.id + " does not implement event " + e);
	    }
	return rval;
	}
    function ifevent_connect_exec(ep)
	{
	var t = eval(this.target);
	if (!t || !t.ifcProbe) 
	    {
	    if (pg_diag)
		alert("Event " + this.name + " -> Action " + this.action + ": target '" + this.target + "' not a widget");
	    return null;
	    }
	var ai = t.ifcProbe(ifAction);
	if (!ai) return null;
	var ap = new Object;
	for(var pn in this.paramlist)
	    {
	    var p = this.paramlist[pn];
	    if (p.type == 'int' || p.type == 'str' || p.type == 'dbl')
		ap[pn] = p.value;
	    else if (p.type == 'sym' || p.type == 'exp')
		{
		if (typeof ep.eval != 'function')
		    ep.eval = eval;
		ap[pn] = ep.eval(p.value);
		}
	    }
	return ai.Invoke(this.action, ap);
	}
    function ifevent_connect(e,t,a,pl)
	{
	if (this.Events[e])
	    {
	    eo = {fn:ifevent_connect_exec, target:t, action:a, paramlist:pl, name:e};
	    eo.eo = eo;
	    this.Events[e].push(eo);
	    }
	else if (pg_diag)
	    alert("Connect event: " + this.obj.id + " does not implement event " + e);
	}
    function ifevent_exists(e)
	{
	return (this.Events[e])?true:false;
	}
    this.Events = new Array();
    this.Add = ifevent_add;
    this.Hook = ifevent_hook;
    this.Activate = ifevent_activate;
    this.Connect = ifevent_connect;
    this.Exists = ifevent_exists;
    this.Clear = ifevent_clear;
    }


// Form Element interface
function ifFormElement(field)
    {
    function iffe_getvalue()
	{
	return this.Value;
	}
    this.Field = field;
    this.Value = null;
    this.PrivSetValue = iffe_priv_setvalue;
    this.PrivSetValueChangeCallback = iffe_priv_setvaluechangecallback;
    this.SetValue = iffe_setvalue;
    this.SetValueChangeCallback = iffe_setvaluechangecallback;
    this.GetValue = iffe_getvalue;
    this.SetFocus = iffe_setfocus;
    this.SetEnabled = iffe_setenabled;
    this.SetReadOnly = iffe_setr
    this.KeyInput = iffe_keyinput;
    }

