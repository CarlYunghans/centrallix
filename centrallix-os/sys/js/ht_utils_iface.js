// Copyright (C) 1998-2004 LightSys Technology Services, Inc.
//
// You may use these files and this library under the terms of the
// GNU Lesser General Public License, Version 2.1, contained in the
// included file "COPYING" or http://www.gnu.org/licenses/lgpl.txt.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.

// client-side interface module

// GLOBALS

var IFC=    {	Layer: null,
		BaseDir: "",
		Categories: new Array(),
		Definitions: new Array(),
		Loading: new Object(),
		Callbacks: new Object(),
		Params: new Object(),
		Handles: new Array()
	    };


function IfcDefinition(path, type)
    {
	this.Path = path;
	this.Type = type;
	this.MajorVersions = new Array();
	this.DEFINITION = true;
    }

// ifc_internal_LoadFinished - callback function, called when an interface def
// has been loaded from the server, and is ready for parsing
function ifc_internal_LoadFinished()
    {
    var tokens;
    var i, maj_v_num, min_v_num;
    var def;
    var def_ref;

	// get the tokens array
	if (IFC.Layer.document) tokens = IFC.Layer.document.links;
	else tokens = IFC.Layer.links;

	def_ref = tokens[tokens.length-1].pathname;
	delete IFC.Loading[def_ref];
	// see if there was an error
	if (tokens.length == 0 || tokens[tokens.length-1].target != "OK")
	    {
	    pg_debug("IFC: Error loading interface from server: ");
	    if (tokens.length > 0) pg_debug(tokens[tokens.length-1].target);
		pg_debug("\n");
	    return;
	    }
	
	pg_debug("IFC: Loaded '"+def_ref+"'interface successfully\n");

	// now start parsing the structure
	i=0;
	def = new IfcDefinition(def_ref, tokens[tokens.length-1].name);
	while (i < tokens.length - 2)
	    {
	    // first tag should be a start tag w/ major and minor version numbers
	    if (tokens[i].target != "start")
		{
		pg_debug("IFC: Expected a major version start tag. Text was '"+tokens[i].target+"'\n");
		return;
		}
	    maj_v_num = parseInt(tokens[i].host.substr(1, tokens[i].host.length-1));
	    if (isNaN(maj_v_num))
		{
		pg_debug("IFC: Invalid major version number '"+tokens[i].host+"'\n");
		return;
		}
	    pg_debug("IFC: Processing major version "+maj_v_num+"\n");
	    i++;    // next tag

	    def.MajorVersions[maj_v_num] = new Array();

	    // process each minor version
	    while (tokens[i].target != "end")
		{
		prop = 0;
		if (tokens[i].target != "start")
		    {
		    pg_debug("IFC: Expected a minor version start tag. Text was '"+tokens[i].target+"'\n");
		    return;
		    }
		min_v_num = parseInt(tokens[i].host.substr(1, tokens[i].host.length-1));
		if (isNaN(min_v_num))
		    {
		    pg_debug("IFC: Invalid minor version number '"+tokens[i].host+"'\n");
		    return;
		    }
		pg_debug("IFC:   Processing minor version "+min_v_num+"\n");
		i++;	// next tag

		def.MajorVersions[maj_v_num][min_v_num] = new Object();
		def.MajorVersions[maj_v_num][min_v_num].HANDLE = true;

		// process each category
		while (tokens[i].target != "end")
		    {
		    pg_debug("IFC:     Processing category '"+tokens[i].host+"'\n");
		    if (tokens[i].target != "end")
			{
			cat = tokens[i].host;
			def.MajorVersions[maj_v_num][min_v_num][cat] = new Object();
			pg_debug(maj_v_num+"."+min_v_num+" "+cat+"\n");
			}
		    i++;
		    // process each property
		    while (tokens[i].target != "end")
			{
			pg_debug("IFC:       Processing property '"+tokens[i].host+"'\n");

			// create the properties object via the inline object instantiation generated by the server
			eval("def.MajorVersions[maj_v_num][min_v_num][cat][tokens[i].host] = "+tokens[i].text);
			i++;
			}
		    i++;
		    }
		i++;	// next tag
		}
	    i++;    // next tag
	    }
	pg_debug("IFC: Done parsing interface definition\n");
	IFC.Definitions[def_ref] = def;
	if (IFC.Callbacks[def_ref] != null) IFC.Callbacks[def_ref](IFC.Params[def_ref]);
	delete IFC.Callbacks[def_ref];
	delete IFC.Params[def_ref];
    }


// ifcLoadDef - instructs the interface module to load an interface
// definition from the server. handles will not be retrievable from
// that definition until it has completed loading
function ifcLoadDef(def_str, func)
    {
	// make sure the path is an absolute reference
	if (def_str[0] != '/') def_str = IFC.BaseDir+"/"+def_str;

	// check to see if it's already been loaded
	if (typeof IFC.Definitions[def_str] != "undefined")
	    {
	    pg_debug("IFC: '"+def_str+"' has already been loaded\n");
	    return;
	    }
	
	// check to see if it's currently loading
	if (typeof IFC.Loading[def_str] != "undefined")
	    {
	    pg_debug("IFC: already loading '"+def_str+"'\n");
	    return;
	    }

	// specify this def as 'loading'
	IFC.Loading[def_str] = true;
	IFC.Callbacks[def_str] = func;

	// now we can start the load
	pg_debug("ifcLoadDef("+def_str+") - starting load\n");
	pg_serialized_load(IFC.Layer, def_str, ifc_internal_LoadFinished);
    }


// ifcGetHandle - retrieves a handle to an interface 
function ifcGetHandle(ifc_str)
    {
    var maj_v_num, min_v_num;
    var path, ver, tmp;
    var def;
    var handle;
    var i, j;
    var cat, member;

	// unpack the major and minor version numbers
	tmp = ifc_str.split('?');
	if (tmp.length != 2)
	    {
	    pg_debug("IFC: in ifcGetHandle, '"+ifc_str+"' is not a valid interface reference\n");
	    return null;
	    }
	path = tmp[0];
	ver = tmp.split(/[.=]/);
	if (ver.length != 3 || ver[0] != 'cx__version')
	    {
	    pg_debug("IFC: in ifcGetHandle, '"+ifc_str+"' has misformatted version\n");
	    return null;
	    }
	maj_v_num = parseInt(ver[1]);
	min_v_num = parseInt(ver[2]);
	if (isNaN(maj_v_num) || isNaN(min_v_num))
	if (ver.length != 3 || ver[0] != 'cx__version')
	    {
	    pg_debug("IFC: in ifcGetHandle, '"+ifc_str+"' has misformatted version number\n");
	    return null;
	    }

	// make sure the path is absolute
	if (path[0] != '/') path = IFC.BaseDir+"/"+path;

	// look up the interface definition
	if ( (def = IFC.Definitions[path]) == null)
	    {
	    pg_debug("IFC: couldn't find interface definition '"+path+"'\n");
	    return null;
	    }

	// build the handle
	return def[maj_v_num][min_v_num];
    }

function ifcInitialize(ifc_base_dir)
    {
	// assign the layer, browser-independently
	// FIXME FIXME This probably isn't such a hot way to do things FIXME FIXME
	if (document.getElementById) IFC.Layer = document.getElementById('ifc_layer');
	else if (document.all) IFC.Layer = document.all['ifc_layer'];
	else if (document.layers) IFC.Layer = document.layers['ifc_layer'];

	IFC.BaseDir = ifc_base_dir;
    }
