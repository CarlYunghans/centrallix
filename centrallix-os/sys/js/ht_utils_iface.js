// Copyright (C) 1998-2004 LightSys Technology Services, Inc.
//
// You may use these files and this library under the terms of the
// GNU Lesser General Public License, Version 2.1, contained in the
// included file "COPYING" or http://www.gnu.org/licenses/lgpl.txt.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.

// client-side interface module

// GLOBALS

var IFC=    {	Layer: null,
		BaseDir: "",
		Categories: new Array(),
		Definitions: new Array(),
		Loading: new Object(),
		Callbacks: new Object(),
		Params: new Object(),
		Handles: new Array()
	    };


function IfcDefinition(path, type)
    {
	this.Path = path;
	this.Type = type;
	this.MajorVersions = new Array();
	this.DEFINITION = true;
    }

// ifc_internal_LoadFinished - callback function, called when an interface def
// has been loaded from the server, and is ready for parsing
function ifc_internal_LoadFinished()
    {
    var tokens;
    var i, maj_v_num, min_v_num;
    var def;
    var def_ref;

	// get the tokens array
	if (IFC.Layer.document) tokens = IFC.Layer.document.links;
	else tokens = IFC.Layer.links;

	def_ref = tokens[tokens.length-1].pathname;
	delete IFC.Loading[def_ref];
	// see if there was an error
	if (tokens.length == 0 || tokens[tokens.length-1].target != "OK")
	    {
	    wgtr_internal_Print("Error loading interface from server");
	    if (tokens.length > 0) wgtr_internal_Print(tokens[tokens.length-1].target);
	    return;
	    }
	
	wgtr_internal_Print("Loaded '"+def_ref+"'interface successfully");

	// now start parsing the structure
	i=0;
	def = new IfcDefinition(def_ref, tokens[tokens.length-1].name);
	while (i < tokens.length - 2)
	    {
	    // first tag should be a start tag w/ major and minor version numbers
	    if (tokens[i].target != "start")
		{
		wgtr_internal_Print("IFC: Expected a major version start tag. Text was '"+tokens[i].target+"'");
		return;
		}
	    maj_v_num = parseInt(tokens[i].host.substr(1, tokens[i].host.length-1));
	    if (isNaN(maj_v_num))
		{
		wgtr_internal_Print("IFC: Invalid major version number '"+tokens[i].host+"'");
		return;
		}
	    wgtr_internal_Print("IFC: Processing major version "+maj_v_num);
	    i++;    // next tag

	    def.MajorVersions[maj_v_num] = new Array();

	    // process each minor version
	    while (tokens[i].target != "end")
		{
		prop = 0;
		if (tokens[i].target != "start")
		    {
		    wgtr_internal_Print("IFC: Expected a minor version start tag. Text was '"+tokens[i].target+"'");
		    return;
		    }
		min_v_num = parseInt(tokens[i].host.substr(1, tokens[i].host.length-1));
		if (isNaN(min_v_num))
		    {
		    wgtr_internal_Print("IFC: Invalid minor version number '"+tokens[i].host+"'");
		    return;
		    }
		wgtr_internal_Print("IFC:   Processing minor version "+min_v_num);
		i++;	// next tag

		def.MajorVersions[maj_v_num][min_v_num] = new Object();
		def.MajorVersions[maj_v_num][min_v_num].HANDLE = true;

		// process each category
		while (tokens[i].target != "end")
		    {
		    wgtr_internal_Print("IFC:     Processing category '"+tokens[i].host+"'");
		    if (tokens[i].target != "end")
			{
			cat = tokens[i].host;
			def.MajorVersions[maj_v_num][min_v_num][cat] = new Object();
			wgtr_internal_Print(maj_v_num+"."+min_v_num+" "+cat);
			}
		    i++;
		    // process each property
		    while (tokens[i].target != "end")
			{
			wgtr_internal_Print("IFC:       Processing property '"+tokens[i].host+"'");

			// create the properties object via the inline object instantiation generated by the server
			eval("def.MajorVersions[maj_v_num][min_v_num][cat][tokens[i].host] = "+tokens[i].text);
			i++;
			}
		    i++;
		    }
		i++;	// next tag
		}
	    i++;    // next tag
	    }
	wgtr_internal_Print("IFC: Done parsing interface definition");
	IFC.Definitions[def_ref] = def;
	if (IFC.Callbacks[def_ref] != null) IFC.Callbacks[def_ref](IFC.Params[def_ref]);
	delete IFC.Callbacks[def_ref];
	delete IFC.Params[def_ref];
    }


// ifcLoadDef - instructs the interface module to load an interface
// definition from the server. handles will not be retrievable from
// that definition until it has completed loading
function ifcLoadDef(def_str, func)
    {
	// make sure the path is an absolute reference
	if (def_str[0] != '/') def_str = IFC.BaseDir+"/"+def_str;

	// check to see if it's already been loaded
	if (typeof IFC.Definitions[def_str] != "undefined")
	    {
	    wgtr_internal_Print(IFC.Definitions[def_str].MajorVersions[1][1]['action']['foo'].cond);
	    wgtr_internal_Print("IFC: '"+def_str+"' has already been loaded");
	    return;
	    }
	
	// check to see if it's currently loading
	if (typeof IFC.Loading[def_str] != "undefined")
	    {
	    wgtr_internal_Print("IFC: already loading '"+def_str+"'");
	    return;
	    }

	// specify this def as 'loading'
	IFC.Loading[def_str] = true;
	IFC.Callbacks[def_str] = func;

	// now we can start the load
	wgtr_internal_Print("ifcLoadDef("+def_str+") - starting load");
	pg_serialized_load(IFC.Layer, def_str, ifc_internal_LoadFinished);
    }


// ifcGetHandle - retrieves a handle to an interface 
function ifcGetHandle(ifc_str)
    {
    var maj_v_num, min_v_num;
    var path, ver, tmp;
    var def;
    var handle;
    var i, j;
    var cat, member;

	// unpack the major and minor version numbers
	tmp = ifc_str.split('?');
	if (tmp.length != 2)
	    {
	    wgtr_internal_Print("IFC: in ifcGetHandle, '"+ifc_str+"' is not a valid interface reference");
	    return null;
	    }
	path = tmp[0];
	ver = tmp.split(/[.=]/);
	if (ver.length != 3 || ver[0] != 'cx__version')
	    {
	    wgtr_internal_Print("IFC: in ifcGetHandle, '"+ifc_str+"' has misformatted version");
	    return null;
	    }
	maj_v_num = parseInt(ver[1]);
	min_v_num = parseInt(ver[2]);
	if (isNaN(maj_v_num) || isNaN(min_v_num))
	if (ver.length != 3 || ver[0] != 'cx__version')
	    {
	    wgtr_internal_Print("IFC: in ifcGetHandle, '"+ifc_str+"' has misformatted version number");
	    return null;
	    }

	// make sure the path is absolute
	if (path[0] != '/') path = IFC.BaseDir+"/"+path;

	// look up the interface definition
	if ( (def = IFC.Definitions[path]) == null)
	    {
	    wgtr_internal_Print("IFC: couldn't find interface definition '"+path+"'");
	    return null;
	    }

	// build the handle
	return def[maj_v_num][min_v_num];
    }

function ifcInitialize(ifc_base_dir)
    {
	// assign the layer, browser-independently
	// FIXME FIXME This probably isn't such a hot way to do things FIXME FIXME
	if (document.getElementById) IFC.Layer = document.getElementById('ifc_layer');
	else if (document.all) IFC.Layer = document.all['ifc_layer'];
	else if (document.layers) IFC.Layer = document.layers['ifc_layer'];

	IFC.BaseDir = ifc_base_dir;
    }
