
*********************************

This file was created by Seth Bird (Thr4wn) to introduce people to
nuances of how centrallix handles javascript.

Please edit this file if there are any mistakes.

Also, online documentation can be found at http://www.centrallix.net/docs/docs.php

*********************************

 See centrallix-os/sys/js/README for more information on how the
 javascript side of things work.

= HTML Generation =

 The model that Centrallix uses is this: instead of directly returning
 HTML pages or using PHP, perl, or other language to generate pages,
 Centrallix generates every web page in C (specifically in htrRender
 function).

 Also, because of the async-hack (see centrallix-os/sys/js/README),
 every HTML request will run through the same algorithm which always
 generates an entire web-page.

 Also, sometimes components are automatically inserted on the server
 side, other times, the client will have to make a separate request
 for it. (At least I (Seth) think that's true)

== htmlgen/*.c files ==

 Pretty much the only thing that these files contain are a *Render and
 a *Initialize function (where * matches the filename (htdrv_*.c))

 The ONLY place that any of the *Initialize functions are actually
 used is inside the cxhtinit function. the cxHtInit function must be
 explicitly called by some application; for example, lsmain (which is
 where centrallix's 'main' function is located) contains an explicit
 call to cxHtInit.

== the *Render functions ==



== Server-side "Classes" ==

 Centrallix has future support for what are called "classes". These
 "clases" are really just different data formats the client can
 request data to be sent as. There is a file where different 'classes'
 can be defined (centrallix/etc/useragent.cfg)

 First of all, the functionality for returning widget-tree data in
 different formats is not even currently (2008-07-11)
 implemented. Second, if it ever does get implemented, some portions
 of code will have to be moved (marked in htrRender() as $$$ MARK:
 server-side classes $$$).



== Unique Endings =

 You'll often see the following javascript functions:

         startup_*, build_wgtr_*, expinit_*

 Where * represents some unique set of letters/numbers. (explanation
 given below)




== format of returned DHTML ==

 (There's an example webpage that the server could return called
 'output_for_default_index.app.html'. Viewing that while reading this
 would probably be very useful.)

 (NOTE: The actual server-side DHTML generation is done within the
 htrRender C function.)

 By the model that centrallix uses, the server never returns the
 actual requested widget-tree. Rather, it returns an entire web-page
 with _instructions_ on how to make the requested widget-tree. Those
 "instructions" are always divided into the following sections:

    * CSS stylesheet information

    * script includes

    * js global variable definitions

    * the js startup_* function

    * the js build_wgtr_* function

    * the js init_inline_interfaces function //currently (2008-07-11) not actually used

    * expinit_*() //currently (2008-07-11) not actually used

    * cleanup() //currently (2008-07-11) not actually used


 the build_wgtr_* function:

   The returned page will contain a javscript Object which mimicks the
   widget-tree's structure (the build_wgtr_* function is responsible
   for making that Object).

 the script includes:

   Then the client is also given (via script includes) all the
   javascript functions/initializers/helpers/etc which will be needed
   to read said js wgtr_Object and to actually create/initialize the
   widgets themselves on the client side.

 the startup_* function:

   The {BODY of the returned webpage}'s onload value will always be
   the javascript startup_* function. This function is what tells the
   client to actually traverse the wgtr_Object and apply said js
   initializers etc.




 Because the requirments/dependencies of each widget vary (and there's
 no need to load every possible item), the server will traverse the
 server-side widget-tree and (while doing that) will keep a separate
 list for each of those sections above and just add items to them one
 at a time as it comes across widgets with new dependencies. Then
 after it has traversed the widget-tree, it will then go through and
 convert the lists into DHTML.






= Scratch writings =

 The file descripter which will ultimately serve as the final,
 returned output is referenced by the 'output' parameter (which, if
 you traverse up the function calls to find it, is conn->ConnFD (for
 whatever use it is to know that)).

 documentation for all server-side generated global js variables are
 in the dynamic_info.js .

//different js functions that relate to asynchronous requests are:

 Every page that the server sends will have defined a global functions
 (startup_*, etc) where * is some unique set of numbers/letters. Note
 that because of the async hack, all the server ever does with widget
 files is return it as a full web page. Because of this and because
 these functions are in global space, the unique identifier is needed
 to prevent overwriting of each other.
