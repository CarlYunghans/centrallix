This is a proposal / design for how we could port Centrallix to Java.

Advantages of porting to Java

* There is a very large and mature ecosystem of libraries that run on the JVM and would be available
  for many of the features that had to be implemented by hand in Centrallix C code. This allows:
  * Many future extensions could be added to Centrallix with less work by using these libraries
  * Much existing C code could be replaced by built-in Java features and third-party libraries
    (see list in a later section below).
* Java is an easier language to work with for less-experienced developers
* Concerns such as memory management are greatly reduced or eliminated
* Much of Centrallix is already object-oriented and Java fits well with this paradigm
* Use of JDBC to access databases would allow a single ObjectDriver that can handle all access to
  relational databases by simply loading the appropriate JDBC driver
* Java has a variety of mature unit testing frameworks, facilitating easier testing
* Easier debugging - Java provides a variety of local and remote debugging tools such as through
  IDEs like IntelliJ

Disadvantages of porting to Java

* Potential performance impact in places where the JVM JIT compiler is not able to make the code
  run as fast at the original C code.
* Performance overhead that occurs in JNI to copy data between C and Java data structures;
  overhead of JNA itself.
* Loss of portability - we would lose the ability to embed Centrallix as, for instance, a Firefox
  extension. To work around this, we would need to compile Java code into native code, but as of
  2019, it appears there are not many options for this. GCJ was a project but has ended and there
  is a commercial product called Excelsior JET. See the link below:
   - https://stackoverflow.com/questions/2991799/can-i-compile-java-to-native-code

Functionality that could be replaced by either built-in Java features or open source third party libraries:

* MTASK / Locking / Semaphore - Java's built-in true threading, locking and concurrency features/libraries
* HTTP server - Tomcat or Jetty servers, which are embeddable within an application
  * REST / HTTP handlers - Java Servlet API
* Dynamic module loading - Java dynamically loads classes from the classpath
* Database drivers - JDBC provides a generic abstraction that can be used against all database systems
* NFS - NFS4J (https://github.com/dCache/nfs4j)
* LDAP - JNDI; Apache Directory API 2.0
* POP3 - JavaMail
* JSON parsing / building - Jackson library
* Domain-specific language - DSLs handlers can be built fairly easily using Groovy (another JVM language
  that interoperates with Java) as the parser and dispatcher mechanism

A Hybrid / Incremental Approach

Given the size of the Centrallix codebase, it is desirable and necessary to be able to port one portion
of the system at a time, while keeping the overall system working. This means we must find a way that Java
and C can interact with one another, so that some modules are in C and others in Java. This allows small
pieces of the codebase to be converted over time, such as during a Codeathon.

The natural choice for integrating C and Java together is either JNI or JNA.

An overview of how JNI works:

* The application starts up and runs within the JVM as a Java process.

* Java code can call into native (C) code by marking a Java class method as "native"
  and then implementing a C function that follows a specific naming convention

* The C code is built as a shared library and loaded at runtime from Java code by
  calling System.loadLibrary("shared-library-filename")

* Threads started from within C code that wish to interact with Java must call
  AttachCurrentThread() to attach themselves to the VM and obtain a JNI interface pointer.
  Once attached, a native thread works like a regular Java thread running within a native
  method. The native thread remains attached to the VM until it calls DetachCurrentThread()
  to detach itself.

* All data passed between C and Java code must be converted, which is typically O(n)
  with respect to the number of data elements and/or array size being converted.

An alternative to JNI is JNA, built on top of JNI, and is easier to use:

* See https://en.wikipedia.org/wiki/Java_Native_Access

* Instead of static binds and special headers, native methods are accessed through a Java
  interface whose method names match those of the native methods to be called.

* The mappings between Java and C data types are customizable, and so is the mapping between
  Java method names and C function names.

* Java code can access pointers from C, through an abstraction.

* C code can call methods on Java objects.

* It appears that JNA is able to allow for less conversion between data types in C and Java,
  but this point needs further investigation.

Reference Documentation

* JNI
    * Overview:  https://en.wikipedia.org/wiki/Java_Native_Interface
    * Tutorial:  https://www.baeldung.com/jni
    * Full docs: https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/jniTOC.html

* JNA
    * Overview:  https://en.wikipedia.org/wiki/Java_Native_Access
    * Source:    https://github.com/java-native-access/jna
    * License:   This library is licensed under the LGPL, version 2.1 or later, and
                 (from version 4.0 onward) the Apache Software License, version 2.0.
                 Commercial license arrangements are negotiable.

General Design

* The main entry point of the application would be a Java main class. This would initialize all
  other systems, such as registering modules.
* Centrallix code will be compiled as one or more shared libraries, as required by JNA.
* A series of Java interfaces would define how various parts of the system interact
    * The interface names and method names could match those already use in Centrallix,
      such as for the Object Drivers, Widgets, and so on.
* Each Object Driver, Widget, etc. would define an implementation of the interface that would
  either be implemented in Java or would be a thin wrapper that would call the C implementation
  via JNA.
    * At first, all Object drivers would simply delegate to C code.
    * Over time, each Object Driver could be reimplemented in Java directly.
* An Object Driver registry will be maintained on the Java side.
    * If an Object Driver is implemented in C code, then the pointer to the driver in OSYS.Drivers
      will be a direct pointer to the C implementation.
    * If a driver is implemented in Java code, then the pointer in OSYS.Drivers will be to facade
      that delegates to the Java implementation.
* To keep things organized, adopt the following naming convention:
    * Java interfaces (for JNA) that directly correspond to C structs should be named like "CTheName"
      where "TheName" is the name of the C struct.
    * Java interfaces that Java classes will use should be named "TheName".
    * Example:
        * The C struct named "ObjDriver" ("_OSD") will have a corresponding JNA Java interface
          named "CObjDriver" that extends "com.sun.jna.Structure"
        * The Java interface that represents Object Drivers in Java will be named "ObjDriver".
    * This separation between Java and C structs/interfaces allows for slight differences between the
      two, and for more natural Java conventions to be used on the Java side. It also will allow the
      C interfaces to be removed when/if all implementations are ported to Java.

Implementation Phases

The following phases could be followed to incrementally port Centrallix to Java:

* Phase 1 - Java wrappers for C Object Drivers
    * At the end of this phase, you will have a Java application that delegates pretty much all functionality
      to the C code.
    * Build all of Centrallix as a shared library, if this is not already part of the Makefile process.
    * Create the initial Java class that starts the whole application.
        * Call the main application entry point for Centrallix, via JNA.
    * Allow Java to know about all of the C Object Drivers.
        * Create a Java interface "CObjectDriver" that extends from JNA Structure and matches the ObjDriver C struct.
        * Create an ObjectDriverRegistry Java class that is capable of keeping track of all the registered
          Object Drivers. It should have a method like "register(CObjectDriver objectDriver)".
        * Create a C function like "setObjectRegistry" that accepts a function pointer to a callback function
          and stores this pointer into a global variable like "ObjectRegistry".
        * In the main java startup class, instantiate the Object Driver registry and pass a reference to it
          to the setObjectRegistry C function above via JNA. This should happen BEFORE calling the main
          Centrallix entry point.
        * In obj_main.c/objRegisterDriver, call the register() via the function pointer from above. JNA
          will route this to the Java ObjectRegistry.
    * Create a generic implementation of the ObjDriver interface that simply delegates to the function pointers
      on a CObjDriver object. This implementation of ObjDriver would be returned to any calling Java code when
      an Object Driver being referenced has a C implementation.
    * Change the main startup script that starts Centrallix to instead call Java with the appropriate command
      line options and classpath.

* Phase 2 - Object Drivers in Java
    * At the end of this phase, you will have one or more Java implementations of Object Drivers, which can be
      called from both C and Java.
    * Modify the dynamic module loading mechanism on the C side to know that a given module has already been
      loaded from the Java side, so that it doesn't try to load it from the C side.
    * Create another function like obj_main.c/objRegisterDriver, named objRegisterDriverExternal. This should
      do the same thing as objRegisterDriver but without registering the driver with the Java ObjectRegistry.
      You could refactor these two methods to reduce duplicate code.
    * Add a register(ObjDriver) method to ObjectRegistry (there is already a register(CObjDriver) from Phase 1).
        * This will be used to register an Object Driver from the java side.
        * After adding the driver to the registry, call the obj_main.c/objRegisterDriverExternal function via
          JNA to register the Java Object Driver on the C side.
    * Choose one or more Object Drivers to be reimplemented in Java. A good choice may be to create a generic
      JDBC Object Driver that can replace the existing MySQL and Sybase implementations.
    * For each Object Driver chosen above:
        * Create a Java class that implements ObjDriver. The methods can all be no-op for now.
        * Instantiate and register the Java Object Driver with the ObjectRegistry during the main startup process.
        * Remove call to initialize the C module from centrallix.c
        * Implement the module in Java. This is where most of your work will be.
        * Add some unit tests (using JUnit, TestNG or Spock) to test your Object Driver.

* Phase 3 - Multithreading, HTTP server and security system
    * At the end of this phase, all incoming HTTP and HTTPS requests will be handled by a Java HTTP server, and
      multi-threading of incoming requests will be handled by Java threads, allowing multiple CPUs to be used.
    * Prepare code for being multi-threaded
        * When working on this phase, care should be taken to investigate whether there are any parts of any of the
          Object Driver implementations that are not thread-safe - i.e. that do any of the following:
            * return or pass references to shared buffers in static storage
            * modify global variable values
            * call other code that does any of the above
        * For any cases where the above occurs, it is necessary to either refactor the C code to not use static
          storage, use an appropriate locking or semaphore mechanism, or add appropriate locking within the Java
          code that wraps the C code, and ensure that all C code that calls this code goes through the Java code
          first as a facade to take advantage of the Java-side locking.
    * Embed a webserver (Jetty or Tomcat) into the Java process and initialize it from the main java startup class
    * Create a Java Servlet class to handle each of type of HTTP or REST request
    * Configure the webserver to pass calls from the outside world to the appropriate Servlets created above
    * TODO figure out how the security system works and how it would need to be implemented here
    * TODO figure out what needs to be done to make TLS work on the webserver

* Phase 4 - Widgets
    * At the end of this phase, you will have one or more Java implementations of Widgets, which can be
      called from both C and Java.
    * TODO consider whether it makes sense to look into other technologies for rendering HTML, such as JSP or JSF