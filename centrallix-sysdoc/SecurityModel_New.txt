Title:	Security subsystem
Author:	Greg Beeley (GRB)
Date:	13-Nov-2012
-------------------------------------------------------------------------------

OVERVIEW

    As a preliminary security step, this document describes the addition of
    limited endorsement functionality to applications and reports.


APPLICATION PROPERTIES

    Applications and components will gain the following properties in order to
    manage user endorsements:

	A.  add_endorsements = string[,string ...]

	    This property allows an application or component to add an
	    endorsement to the context that the user is operating within.  If
	    specified with a subquery-style SQL statement, multiple
	    endorsements can be added from a database backend, for instance.

    All widgets can have the following properties:

	A.  require_endorsements = string[,string ...]

	    This specifies a list of one or more endorsements that a widget
	    requires in order to render property.


SUBJECT IDENTIFIERS

    Subject identifiers must distinguish between a specific user, a group that
    a user is in, or a role that a user is acting in.

    There are four types of subject identifiers that don't identify a specific
    subject.  These are a:, l:, c:, and e:, and are described below.

    u:username	- A user with logon 'username'
    g:grpname	- A group with group name 'grpname'
    r:rolename	- A role with role name 'rolename'
    a:		- A user who has not authenticated ('anonymous')
    l:		- A logged-in/authenticated user
    c:		- The creator/author of a given object
    e:		- Everyone

    The c: subject identifier is context-dependent.  It is used to refer to the
    creator of a given object, and so is dependent on which object is being
    accessed.


OBJECT/ATTRIBUTE IDENTIFIERS

    The object identifier will have the capability of referring to an object
    type, specific object, attribute for a type of object, or attribute within
    a specific object.  It may also refer to all objects within a given
    application.

    The general object ID specification is formatted thus:

	appname:objecttype:objectname:attrname

    In specific instances, the following are also accepted.  An unspecified
    name or type is a wildcard.

    A.	All objects belonging to a specific application:

	appname:::

    B.	All attributes of a given name within an application:

	appname:::attrname

    C.	All objects of a specific type in an application:

	appname:objecttype::

    D.	A specific object within an application:

	appname:objecttype:objectname:
	appname:objecttype:/path/to/objectname:
	appname:objecttype:/objects/within/*:

    E.	An attribute of a type of object in an app:

	appname:objecttype::attrname

    F.	An attribute of a specific object:

	appname:objecttype:objectname:attrname


ENDORSEMENT IDENTIFIERS

    Likewise, endorsements also have an application-specific naming convention:

	appname:endorsementname

    The appname 'system' is used for internal Centrallix endorsements.  A list
    of internal endorsements follows:

	system:from_application	- provides assurance that the current context
				  was invoked from a running application that
				  has a valid SGA Key (session management and
				  CSRF token).  Reports and other objects that
				  make changes without additional user
				  interaction, or use large amounts of system
				  resources, may require this endorsement to
				  prevent a security compromise or denial of
				  service attack.


ACCESS TYPES

    There are seven access types that Centrallix uses:

    create	- permission to create a new object of the type
    delete	- permission to delete an object of the type
    observe	- permission to observe that an object exists
    read	- permission to read the content of an object or attribute
    write	- permission to write to an object or attribute
    execute	- permission to 'execute' an object, which usually means
		  opening it using its associated objectsystem driver,
		  instead of just opening the underlying object.
    noexecute	- permission to open an object without automatic 'execution',
		  basically controlling the use of open-as (ls__type)
		  processing and the EXEC/NOEXEC flags on queries and opens.

    Access Type interactions:

    - If observe is allowed but read is not, the subject will be able to
      notice the existence of the object but not view its attributes or
      contents.

    - If read is allowed but observe is not, the subject will be able to
      access the object only if the subject already knows the object's name
      (i.e., location in the objectsystem).  The object will not show up in
      a subobject query on its parent, unless the object is a node object
      and the query is done without EXEC (e.g., say an object of a database
      node type has restricted access; it would not show up if the query
      were set up to exec all nodes it finds.  If the query was running in
      a noexec manner, the nodes would not be invoked and the underlying
      file would be visible in the query unless otherwise restricted).

    - With both 'execute' and 'noexecute' permissions on an object type, the
      subject can decide whether or not to access a node object as the
      underlying object (say, a file object), or as the object type in
      question (say, a database node object).  This is done via ls__type (to
      be very specific about what type to open as), or via the open flags
      OBJ_O_EXEC / OBJ_O_NOEXEC.

    - If neither 'execute' nor 'noexecute' is granted for an object type,
      then the object cannot be opened as the type in question or as the
      underlying object type.

    - If 'execute' permission is granted but not 'noexecute', then the
      object cannot be opened as its underlying object type.  This can be
      used to prevent access to sensitive information in the underlying
      source code of the object, or to prevent access to data except through
      "official" means (e.g., accessing rows in a CSV file vs. accessing the
      actual textual content of the CSV file; or accessing a database vs.
      being able to see the connection information, possibly including
      passwords, in the underlying database connector file).

    - If 'noexecute' is granted but not 'execute', then the object cannot
      be opened as the type in question, but the underlying object can be
      opened.  For example, if execute is forbidden on 'shell' objects, then
      the user would be able to view the underlying shell object file that
      describes what command is to be executed, but the subject would not be
      able to open the object and cause the command to be run.  Similarly,
      if the object were a CSV file, the subject would be able to view the
      raw CSV file data, but not open the file and query its individual rows.


SECURITY TYPE DECLARATIONS

    Various data sources within Centrallix will need to declare the security
    type associated with the source's data.  For example, a database connector
    object may need to declare the security type of the database, its tables,
    and the rows within the various tables.  There could be one generic type
    for all rows, with the ability to specify an alternate type for rows in
    specific tables.  This same concept can apply to fields within tables as
    well.


APPLICATION-SPECIFIC SECURITY CONFIGURATION

    The security policy may permit sub-policies to exist at different levels
    within the ObjectSystem.  In that case, when accessing data and apps,
    the system will probe for security policy configuration objects (files)
    within various folders in the path.


SECURITY POLICY FILE

    The security policy file will be a structure file.  See the file

	SecurityModel_SamplePolicy.pol

    for a sample of how a policy file is constructed.


SIGNING KEY CONFIGURATION

    A security policy file may define what signing keys are used to identify
    an object as having been authored by a specific identity.  The public key
    of an RSA key pair will be included in or referenced by the policy file
    in a subjectkey directive.


AUTHENTICATION MAPPING AND TOKEN STORAGE

    The security subsystem will often need to map identities between the
    Centrallix server and local or remote data sources, and authentication
    tokens may need to be stored to permit access to those remote sources.
    Furthermore, sometimes a user may need to connect to a remote source
    as a different identity, and that information can be stored as well.

    The basic premise of the key repository is that the stored auth tokens
    (passwords, cookies, oauth1/2 tokens, etc.) will be encrypted with the
    user's login password (or other persistent authentication token) as the
    primary key dependency.  If the user's login password changes, then the
    system will need to prompt the user for their old password in order to
    update the key repository.
-------------------------------------------------------------------------------
