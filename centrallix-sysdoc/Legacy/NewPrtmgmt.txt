Document:  Rewrite of print management module for LightServer
Author:    Greg Beeley (GRB)
Date:      April 14th, 2000
-------------------------------------------------------------------------------


OVERVIEW

    So it turns out that the second-generation print management module did not
    hold up under the requirements it was to have.  The second-generation
    module was written to include functionality like columnar output, word-
    wrapping, and pagination.  These features worked very well, but it turned
    out that so much more was to be demanded of the module that another rewrite
    is needed.  Sigh.  So, this is the third-generation print management 
    module.


BASICS

    The first print management module was built around the idea of processing
    a printing command as soon as it was sent to the module.  The second print
    managment module allowed the queueing of commands so that they could be
    handled as a group -- thus word-wrapping and pagination, and tabular and
    columnar output.

    This new module will handle the printing process in several stages.  These
    stages are detailed below.

    1.  COMMAND phase

        The command phase is when the calling module (such as the report object
	driver) places requests through the print management module.  These 
	requests can be "print string" "start table" "set margins", etc.  These
	requests will be serializable so that the printing process can be 
	repeated if need be.  The commands are expressed not only as the
	exposed print management API, but also in the serialized command-stream
	format internally.  A few examples:
	 
	    WriteString	(string of text, optionally with newlines/tabs/etc)
	    WriteNL	(newline)
	    WriteFF   	(form feed)
	    WriteLine 	(horizontal rule)
	    BeginTable	(start a new table)
	    EndTable	(end an existing table)

    2.  STRUCTURE phase

        The structure phase results from the actions of the print managment API
	when those routines are called.  The print management API will organize
	the data and commands into internal structures that represent the 
	elements of the document to be printed.  Some structural elements are
	listed below:

	    Section	(an in-flow container, possibly multicolumn, with such
	    		 attributes as margins, style, etc)
	    Table	(a tabular data presentation device, having rowwise
	    		 and columnwise containers for more data)
	    String	(a string of text with a given format,font,color,etc)
	    Area	(an out-of-flow container, positioned on the page)
	    Picture	(an image with a width & height)

	Elements which are containers (section,table,area) will be able to have
	some properties for the container area, such as justification, width
	of container area, etc.  The idea is to allow anything that is a 
	container to contain any other thing(s).

    3.  LAYOUT phase

        In the layout phase, the print management system takes the organized
	information from the structure phase and performs a layout operation
	on that information.  Layout involves determining the exact positioning
	of every element and container on the printed page, by performing the
	following tasks:

	    - word wrapping textual areas.
	    - justifying textual areas once word-wrapped.
	    - determining correct locations for page breaks, based on available
	      remaining page space (multiplied by <n> for multicolumn areas).
	    - determining the relative locations of objects within their
	      containers, from the bottom-up.
	    - determining the absolute locations of objects on the page, from
	      the top-down.

	Optimally, the layout phase should occur while the command/structure
	phases are in process, so that pages can be printed as they are ready,
	thus conserving memory utilization.

	Note: because of potential line spacing changes within a multicolumn
	section, care must be taken to appropriately ration the data between
	the <n> columns, as fewer lines may fit than may appear to fit.

    4.  PRINT/GENERATION phase

        In this step, the layout is converted into commands to be sent to the
	appropriate printing driver.  This involves a few steps, and the 
	document is printed row-wise in order to make possible plaintext 
	output, dot matrix printing, and PCL printing where the printer has
	too little memory to handle a whole page at once (such as with HP
	inkjet printers).

	    - First, ALL objectstream structures are sorted by their absolute
	      Y position on the page.  There are prev/next pointers in the 
	      objectstream structures to allow for this.  The optimal sort
	      algorithm is to perform a selection/merge sort.
	    - Next, the structures are retrieved in their groups by Y position
	      to generate the page.  Partial line-feeds can occur to scroll to
	      the position needed for the next section of Y-position elements.
	    - Pictures are handled by only printing <n> raster lines at a time,
	      and incrementing a vertical counter to show "how far down" in the
	      image we got.  If no more Y positioned structures are between the
	      current image position and end of image, the whole thing can be
	      finished without worrying about the vertical counter.


THE COMMAND PHASE, AND ITS CONVERSION TO THE STRUCTURE...

    This section provides more detailed information about the command phase.
    That is, it provides information about the print management API and what
    the various API functions must achieve.


    SESSION COMMANDS....

    prtOpenSession

        This function opens a new session with a given content type, output
	descriptor, and output function.

	    - Lookup a driver for requested content type (err if not found).
	    - Allocate a session structure.
	    - Set width = 80.0 10ths of an inch.
	    - Set height = 66.0 6ths of an inch.
	    - Set header count, footer count to 0.
	    - Set header lines, footer lines to 0.
	    - Set page number to 1.
	    - Set write fn, write arg, content type.
	    - Call the open function on the driver.
	    - Allocate a section objstream element and set the head/ptr.

    prtCloseSession

        This function cleans up the printing session, prints the remaining last
	page if need be, and exits out.

	    - Issue a FormFeed (prtWriteFF) if need be.  To determine this, 
	      check the objstream.  If there are any sections/tables/areas in
	      effect other than the top-level section, or if the current 
	      container has non-empty strings or pictures in it, issue the FF.
	    - Call the close function on the driver.
	    - Deallocate any objstream structure tree.
	    - Deallocate the session structure.


    TEXTSTREAM COMMANDS....

    prtWriteString

        This function writes a string of textual data to the printing system,
	with font/size/formatting/spacing/justification as currently defined.

	    - If just starting a new line (line begins with an empty-string
	      entity, of 0 width 0 start), check pagination before doing any-
	      thing else.
	    - If the string contains newlines, tabs, or returns, break the
	      string into multiple parts, and handle the control characters
	      by issuing prtWriteNL, prtSetHPos, and such.
	    - Allocate a new objstream element for the new string.
	    - Call the driver to determine its printed width.
	    - Set RelativeX to the previous string element's RelativeX plus
	      Width.
	    - If this element's RelativeX plus Width is greater than the 
	      parent container's AvailablePageWidth value, perform word-
	      wrapping on the text.
	    - If word-wrapping was performed, perform justification on the
	      original line of text.
	    - If word-wrapping was performed, check the new RelativeY of the
	      newly started line against the AvailablePageHeight of the parent
	      container.  If the RelativeY is greater-than the available 
	      height, perform an automatic page break operation.

    prtWriteNL

        This function ends the current line of text and moves the current print
	location to the next line.

	    - If already starting a new line (line begins with an empty-string
	      entity, of 0 width 0 start), check pagination before doing any-
	      thing else.
	    - Add a new empty-string entity in the current command stream with
	      RelativeX at 0, Width of 0, and RelativeY incremented according
	      to the current lines-per-inch value, and a height value according
	      to the current font.
	    - Do NOT do word-wrapping on the terminated line.
	    - Only do justification on the terminated line if the justification
	      style is centered or right (don't do full justification).
	    - Do NOT perform page-break checking yet.  This allows the user to
	      fill the entire page with text (including the ending WriteNL),
	      and then write an absolute positioned area somewhere on the page.
	      Page break check will be done next time some text is added to the
	      line or when another NL or FF is performed.

    prtWriteFF

        This function ends the current page and causes the current page to be
	printed.

	    - Force a page-break.  See the LAYOUT logic section for information
	      on how a page break is performed (it involves retaining much of
	      the structure while removing the printed content).
	
    prtWriteLine

        This function causes a horizontal line to be drawn across the printable
	area within the current container.  The horizontal line takes up one 
	line's worth of text space.

	    - If the current print position is NOT at the left margin/edge, do
	      a newline first (prtWriteNL).
	    - Create a new Picture element, using a one-pixel 24bpp image that
	      is the color of the current FGColor, with the inflow flag set.
	      The image should take up an entire line.
	    - Add an empty string to begin the next new line.
	    - Check page break.


    STYLE AND ATTRIBUTE COMMANDS....

    prtSetAttr
    prtGetAttr

	These functions get and set the current text attributes, including 
	bold, italic, underline, and postal service bar code styles.

	    GetAttr:
	    - Return the attributes of the element pointed to by the current
	      stream pointer in the session structure.

	    SetAttr:
	    - Build a new empty-string element with ATTRCHANGED set, and add
	      it to the objectstream.

    prtSetFont
    prtGetFont

        These functions get and set the current font, by font name.  Currently
	supported fonts are the following:

	    PRT_FONT_COURIER:	"fixed","courier","courier new"
	    PRT_FONT_HELVETICA:	"proportional","helvetica","arial","univers"
	    PRT_FONT_TIMES:	"times", "cg times", "times new roman"

	    GetFont:
	    - Return the font of the current stream pointer's element.

	    SetFont:
	    - Build a new empty-string element with ATTRCHANGED set, and add
	      it to the objectstream.

    prtSetFontSize
    prtGetFontSize

        These functions get and set the current font point size.  Internally
	the closest match will be used, but GetFontSize will always return the
	value set by SetFontSize.

	    GetFontSize:
	    - Return the font size of the current stream pointer's element.

	    SetFontSize:
	    - Build a new empty-string element with ATTRCHANGED set, and add
	      it to the objectstream.

    prtSetColor
    prtGetColor

        These functions set and get the current text foreground color.  The
	background color is set as a part of section, area, and table cells.

	    GetColor:
	    - Return the FGColor of the current stream pointer's element.

	    SetColor:
	    - Build a new empty-string element with ATTRCHANGED set, and add
	      it to the objectstream.


    FLOW AND LAYOUT COMMANDS....

    prtSetJustification
    prtGetJustification

        These functions get and set the current text justification.

	    GetJustification:
	    - Return the justification of the current stream pointer's element.

	    SetJustification:
	    - Build a new empty-string element with ATTRCHANGED set, and add
	      it to the objectstream.

    prtSetLineSpacing
    prtGetLineSpacing

        These functions get and set the line spacing, and will apply to all
	subsequent line breaks, whether caused by word-wrapping or by explicit
	newlines.

	    GetLineSpacing:
	    - Return the line spacing of the current stream pointer's element.

	    SetLineSpacing:
	    - Build a new empty-string element with ATTRCHANGED set, and add
	      it to the objectstream.

    prtSetPosition

        This function sets the current printing position by setting the 
	relative-X and/or relative-Y positions.  Relative-X can be set without
	setting relative-Y, but not vice-versa (if the y position is set
	without an X value, X is set to the left margin).

	    - If Y is specified but X is set to unspecified (-1), set X to the
	      correct relative value of the left margin (normally 0, unless
	      the LMargin value for a section is set).
	    - Build a new empty-string element with POSITIONED set, and add it
	      to the objectstream with a new X and Y position.


    LAYOUT OBJECT COMMANDS....

    prtBeginSection
    prtEndSection

        These commands start and end a section element.  A section element is
	an in-flow container with margins and columns.

	    BeginSection:
	    - Create a new Section element, set its attributes, and add it to
	      the objectstream.
	    - Create an empty-string element and add it as a child element of
	      the Section, to the InitialStream pointer.
	    - Set the current stream pointer in the session structure to the
	      empty string element just created.
	    - Compute the section's available height and width from the various
	      attributes specified for it.

	    EndSection:
	    - It is an error if the current stream pointer's parent reference
	      isn't a Section element (illegal mixed-up nesting).
	    - Move the current stream pointer back to the Section element 
	      itself instead of being in the substream of the Section element.
	    - Perform any justification needed on the final line of text in
	      the section.

    prtBeginArea
    prtEndArea

        These commands start and end an area element.  Areas are generally out-
	of-flow elements with absolute positioning, but always have a definite
	width and height and do not flow from one page to the next like a 
	section can.

	    BeginArea:
	    - Create a new Area element, and set its attributes.
	    - Do in-flow/out-of-flow/flow-around layout positioning logic.
	    - Create a new empty-string element and add it as the first element
	      in the Content pointer for the area.
	    - Set the current stream pointer to the empty-string element.

	    EndArea:
	    - It is an error if the current stream pointer's parent reference
	      isn't an Area element (illegal mixed-up nesting).
	    - Move the current stream pointer back to the area element itself,
	      or depending on in-flow/flow-around positioning, to the end of
	      the text after the Area element.
	    - Perform any justification needed on the final line of text in the
	      Area.

    prtBeginTable
    
        This command starts a new table.

	    - Create a new Table element, set its attributes, and add to the
	      objstream.
	    - If already at beginning of a line, don't do a newline operation
	      first, otherwise, do a newline first (and justify that text).
	    - Set the current-stream pointer to the Table element itself.  This
	      is a bit inconsistent, but necessary because of the rows/cells
	      architecture.

    prtEndTable

        This command ends a table.

	    - Make sure the table's height is calculated, by looking at the 
	      end-objstream elements in the table's Rows listing.
	    - Create a new empty-string objstream element, and add it in 
	      sequence following the table (not in the table!).
	    - Set the current objstream pointer to that empty-string element.
	    - Perform justification on the table as a whole, if needed (center,
	      right, or left).

    prtBeginRow

        This command starts a new table row, whether header or body.

	    - The current objstream element must either be a Table element or
	      a Row element.
	    - Create a new Row Element, with IsHdrRow set if indicated in this
	      routine's parameters.
	    - Add the element to Rows or HdrRow of the table, as is 
	      appropriate.
	    - Set the current objstream pointer to that row element.

    prtDoColumn

        This command starts a column within the table, or a column header,
	based on whether a header-row was indicated in the BeginRow operation.
	All text and objects printed between after a DoColumn and before the
	next DoColumn or EndRow will be within that cell of the table.

	    - It is an error if the current objstream element is not a Row
	      element, or if its parent is not a Cell element.
	    - Perform justification on the last line of the most recent cell,
	      if needed.
	    - Create a new Cell, and set its parent to the Row element.
	    - Set the cell's width to the width of the first cell in this 
	      column if there is one (including header), or to the requested
	      width if there isn't a previous cell in this column.
	    - Create a new empty-string element and place it in the Cell's
	      content.
	    - Point the current objstream pointer to the empty string element.

    prtEndRow

        This command ends a table row.  Any printing done after an EndRow but
	before another BeginRow/DoColumn will be outside of the table's 
	formatting controls but within the formatting controls of the parent
	container.

	    - It is an error if the current objstream element is not a Row
	      element, or if its parent is not a Cell element.
	    - Perform justification on the last line of the most recent cell,
	      if needed.
	    - Set the current objstream pointer to the most recent Row
	      element.
	    - If full justification was requested on the table, adjust all
	      column widths to full-justify the table, re-wrap all table cells,
	      and re-check pagination.

    prtWritePicture

        This command creates a new Picture, either in-flow or out-of-flow.  The
	pixel data is provided along with this command.


    HEADER AND FOOTER COMMANDS....

    prtSetHeader
    prtSetFooter

        These commands add a header or footer.  Headers and footers are unique
	in that they only apply at the page-level, and are dynamically 
	generated at the start and end of the page.  Thus, headers and footers
	can contain data and information (such as page numbering) that is
	computed dynamically.

	When the time comes for the generation of a header or footer, the print
	management system will invoke a callback function to the calling 
	application, during which invocation the application should call the
	normal printing routines to build the header or footer.

    prtRemoveHeader
    prtRemoveFooter

        These functions remove a header or footer from the current session.


    MISC COMMANDS....

    prtSetPageNumber
    prtGetPageNumber

        These functions get and set the internal page number counter.  The page
	number by default starts at 1, but this setting can be changed.

    prtSetPageGeom
    prtGetPageGeom

        This function sets the expected physical dimensions of the paper or 
	other media being printed to, in 10ths of an inch for the printable
	width, and in 6ths of an inch for the printable height.  These strange
	units are used because they are the normal units for plain fixed-pitch
	printing (10cpi and 6lpi).


THE STRUCTURED OBJECTSTREAM

    The objectstream tree provides the internal layout mechanism for the page.
    This section of the design provides information as to how each of the
    members of this structure tree are used.

    Magic (unsigned int)

        This value is always set to MGK_PRTOBJSTRM (currently 0x12340502) when
	the structure is allocated, and should be checked in every routine 
	which handles these structures before the structure itself is accessed.
	Checking is done by the ASSERTMAGIC macro, as in

	    ASSERTMAGIC(structureptr, MGK_PRTOBJSTRM)

	with no trailing semicolon.  With -DCHECKED enabled in the build, this
	will cause a break into the debugger (via a forced SIGSEGV) if the
	magic value is not correct.  With -DCHECKED not defined, the macro is
	empty, so for a production release where speed is critical, no added
	code is necessary.

    Next (self *)

        This is a pointer to the next element in the objectstream, or NULL if
	the current element is the last one.

    Prev (self *)

        This is a pointer to the previous element in the objectstream, or NULL
	if the current element is the first one.

    Parent (self*)

        This is a pointer to the parent element in the objectstream tree, and
	may only be NULL if the element is the top-level section.

    YNext (self*)

        This is a pointer to the next element when the objectstream elements
	are sorted by AbsoluteY values.  This and YPrev link the elements in 
	sorted AbsoluteY order so the printing mechanism can print the sections
	of the document one row at a time, in order from top of page to bottom.

    YPrev (self*)

        A pointer to the previous element when the objectstream elements are
	sorted by AbsoluteY values.

    Type (int)

        The "type" of the current element.  Valid types right now are String,
	Table, TableRow, TableCell, Section, Area, and Picture, and are defined
	as PRT_OS_T_xxx in "prtmgmt_new.h".

    Attributes (int)

        The style of the current string, or the overall style of the container.
	This is a bitmask and can contain the values PRT_TX_xxx, in the file
	"prtmgmt_new.h".  Valid values are bold, underline, italic, and postal
	bar code.  The printmanagement system accepts also the values center,
	expanded, and compressed, although these styles are now handled by 
	the FontSize and Justification values now instead.

    FGColor (int)

        The foreground color for this text, or the default foreground color for
	text in this container.  This value is in the format "0x00RRGGBB", and
	is identical in structure to the hex color values used in HTML.

    BGColor (int)

        The background color for this container, applying to the background of
	all text in the container.  This element will not necessarily be fully
	supported, especially early-on.

    Font (unsigned char)

        The numeric identifier for the selected font.  The system currently 
	knows about "courier", "times", and "helvetica", and the relevant 
	definitions are in "prtmgmt_new.h" as PRT_FONT_xxx.

    FontSize (unsigned char)

        The point size of the font for this text, or the default point size for
	text within this container.  Size used to be handled by the style 
	attributes "compressed" and "expanded" but now is handled by a point
	value.

    Flags (unsigned char)

        A bitmask containing any special flags for this element.  Possible 
	values are the following:

	    PRT_OS_F_POSITIONED   This indicates that the current element was
	    			  positioned manually and should not be subject
				  to re-positioning by the various layout 
				  mechanisms (e.g., justification and word
				  wrapping).

	    PRT_OS_F_SETJUSTIFY	  This indicates that the current element 
	    			  represents a change in the justification
				  style of the text stream.  Basically, this
				  automatically begins a new paragraph.

	    PRT_OS_F_ATTRCHANGED  Indicates that the style attributes and such
	    			  changed with this command.

	    PRT_OS_F_CLIPWIDTH	  Indicates that word wrapping should not be
	    			  performed in this container, but rather text
				  should be clipped when it reaches the right
				  edge of the container.  The width to clip at
				  is specified by ClipWidth, see below.

	    PRT_OS_F_CLIPHEIGHT	  Indicates that the AvailableHeight value for
	    			  this container causes any stuff that doesn't
				  fit to be truncated instead of wrapping to a
				  new page.  See ClipHeight, the value to 
				  truncate text at.

	    PRT_OS_F_BREAK	  Indicates that no justification should be 
	    			  performed on the line that is terminated by
				  this objectstream element.  This basically
				  occurs when a WriteFF, WriteNL, or WriteLine
				  occurs (or equivalent control char), to 
				  indicate a break of kinds between one text
				  string and the next.

	    PRT_OS_F_INFLOW	  When set on a picture or area, indicates that
	    			  this picture or area is in-flow rather than
				  absolute and that the formatter should 
				  include it as a part of the text-stream.

	    PRT_OS_F_FLOWAROUND	  When set on a picture or area, indicates that
	    			  multiple lines of text should be allowed to
				  flow around this element, instead of the
				  height of the element effectively setting the
				  height of the line if it is taller than the
				  text.  The x-positioning and width are then
				  honored for the picture, but the y-position
				  is not honored (y-position is determined by
				  the position in the text stream where the 
				  image is placed).

				  If this flag is provided on an image or area
				  that is NOT marked as "in-flow", it will
				  affect any flowable text that might go right
				  underneath the image, but both the Y and X
				  position of the image will be honored.

    Justification (unsigned char)

        This value indicates the type of justification to be performed on the
	fully-wrapped text.  The possible values are listed in "prtmgmt_new.h",
	and are PRT_JST_xxx, having values of left, center, right, and full.
	Left justification does nothing.  Center, Right, and Full re-align the
	text in each line so that the line is properly justified.  Positioned
	elements (see PRT_OS_F_POSITIONED, in Flags above) won't be affected
	by the justification algorithm.

    LinesPerInch (double)

        This value tells how many lines will be generated per inch on the 
	printed page.  The default is 6.0.

    RelativeX (double)

        Indicates the leftmost edge of the container or text string, in 10ths
	of an inch on the page, relative to the container the object is within.

    RelativeY (double)

        Indicates the topmost edge of the container or text string, in 6ths of
	an inch.  Note that THIS DOES NOT indicate the font baseline for 
	printed text, but rather the top edge.  To compute the font baseline, 
	add the Height value to this value.

    AbsoluteX (double)

        The leftmost edge of the container or text, relative to the page, in
	10ths of an inch.

    AbsoluteY (double)

        The topmost edge of the container or text, relative to the page, in 
	6ths of an inch.

    Width (double)

        The width of the container or text in 10ths of an inch.

    Height (double)

        The height of the container or text in 6ths of an inch.

    AvailablePageHeight (double)

        Relevant to containers only; indicates the available height in the 
	container that can be consumed before a page break will be forced.  For
	the top-level section, this will be set to the height of the page.  If
	the top-level section were multicolumn, this would be set to the height
	of the page multiplied by the number of columns.

    AvailablePageWidth (double)

        Relevant to containers only; indicates the amount of horizontal space
	that can be filled before word-wrapping must occur, or if the flag
	PRT_OS_F_CLIPWIDTH is set, this value is ignored and the text is 
	instead truncated at the ClipWidth value.

    ClipHeight (double)

        Relevant to containers only; and only valid if PRT_OS_F_CLIPHEIGHT is
	set in the Flags value.  This indicates where the text in the container
	should be truncated vertically (such as in a table cell where a maximum
	vertical size is given).

    ClipWidth (double)

        Relevant to containers and only valid if PRT_OS_F_CLIPWIDTH is set.
	Causes the text to be truncated instead of wrapped when it reaches a
	given horizontal width.

    String.Length (int)

        Gives the length, in characters, of the string of text.

    String.Text (char*)

        Gives the text to be printed.  Should NOT contain any newlines, returns
	or tabs, which should all be filtered out during the creation of this
	objectstream element.

    Table.nColumns (int)

        Number of columns in the given table.

    Table.TableFlags (int)

        A bitmask of possible flags for the given table.  Flags include the 
	following:

	    PRT_T_F_NOTITLE	Omit the header line and header-body separator
	    			from the table.

	    PRT_T_F_RELCOLWIDTH	Indicates that the column widths, instead of
	    			being in 10ths of an inch, are in units of the
				width of a space ' ' character in the current
				font at its current size.  This is probably a
				deprecated value; that is, the routine that
				creates the table element should really adjust
				for this flag then, and convert the units of 
				the ColWidths array.

	    PRT_T_F_LOWERSEP	Emit another separator at the bottom of the
	    			table as well as between the header and body.

    Table.ColWidths (XArray of int)

        Gives the widths, in 10ths of an inch, for all columns in the table.

    Table.Rows (self*)
     
        Points to an objectstream of TableRow type elements; one for each row
	in the table.

    Table.HdrRow (self*)

        Points to one TableRow object containing the header row for the table.

    Table.ColSep (double)

        The amount of space, in 10ths of an inch, between the columns (or 
	relative to the font if PRT_T_F_RELCOLWIDTH is given).

    TableRow.Columns (self*)

        Points to an objectstream of TableCell elements; one for each cell 
	within the row.

    TableRow.IsHdrRow (int)

        Set to 1 if this row is a header row.

    TableCell.ColSpan (int)

        The number of columns occupied by the cell.  Normally 1.

    TableCell.ColID (int)

        The identifier for the position of the column in the table, ranging 
	from 0 to nColumns - 1.  If the ColSpan is greater than 1, this 
	identifies the id of the first column being occupied by the cell.

    TableCell.Content (self*)

        Points to the objectstream of content within this table cell.

    Section.LMargin (double)

	This is the amount of space to leave on the left hand side of the 
	section before starting the normal printing of text.  Note that this
	value is _added_ to the RelativeX/AbsoluteX value of the section itself
	to determine where to start printing text.  Sub-containers within the
	section are not subject to the left/right margins in a section, but
	instead are relative to the left edge of the section.

    Section.RMargin (double)

        The right hand side margin of a section for text contained within the
	section.

    Section.nColumns (int)

        The number of columns in the section.

    Section.ColWidth (double)

        The width of each column in the section.  This is a function of the 
	overall section width, the margins of the section, and the column
	separation amount for the section, as in:

	    ColWidth = (Width - (LMargin+RMargin) - ColSep*(nColumns-1))/
	                nColumns

    Section.InitialStream (self*)

        The objectstream of the section contents, before the contents get 
	divided up into the separate columns.  During the initial command/
	structure phases, the section appears to be one long page instead of
	separate columns, and the columns are divided up later.

    Section.Streams (array of self*)

        This is a list of pointers to objectstreams for the section after its
	contents have been divided up between the various columns.  In practice
	these pointers may simply point into the InitialStream objectstream and
	thus be just reference values for the individual columns.

    Section.Header (self*)

        An objstream list containing the header for the section that is to 
	repeat on subsequent pages, or even at the top of each column within
	the section, depending on the value of HdrEachCol.

    Section.HdrEachCol (int)

        If set to 1, indicates that the section header (see Section.Header) is
	to repeat at the top of each column instead of just at the top of the
	first column on each page (for single-column sections this setting does
	nothing).

    Area.XPos (double)

        The x-position of the absolutely-positioned area, within the context of
	its container.

    Area.YPos (double)

        The y-position of the absolutely-positioned area, within the context of
	its container.

    Area.Width (double)

        The width, in 10ths of an inch, of the absolutely-positioned area.

    Area.Height (double)

        The height, in 6ths of an inch, of the absolutely-positioned area.

    Area.TextOffset (double)

        See the description of TextOffset in the Picture section, below.

    Area.Content (self*)

        The objectstream of content within this area.

    Picture.XPos (double)

        The x-position of the absolutely-positioned picture/image, within the
	context of its container.

    Picture.YPos (double)

        The y-position of the absolutely-positioned picture/image, within the 
	context of its container.

    Picture.VisualWidth (double)

        The width, in 10ths of an inch, of the picture as printed on the page.

    Picture.VisualHeight (double)

        The height, in 6ths of an inch, of the picture as printed on the page.

    Picture.PixelWidth (int)

        The number of pixels across for the image, from left edge of the 
	printed picture to the right edge.  See DataPixelWidth also.

    Picture.PixelHeight (int)

        The number of pixels from top to bottom of the printed picture.  See
	also DataPixelHeight.

    Picture.DataPixelWidth (int)

        The number of pixels of actual data in the picture.  This does not have
	to be the same as PixelWidth.  This value represents the width in 
	pixels of the picture data itself, while PixelWidth represents the 
	width in pixels of the printed image.  Thus, if PixelWidth is greater
	than DataPixelWidth, the image will be tiled repeatedly to fill the 
	vacant space.  If PixelWidth is less than DataPixelWidth, the image 
	will be truncated.

    Picture.DataPixelHeight (int)

        The number of pixels of actual height in the picture.  See the
	explanation of DataPixelWidth for more information about how this value
	relates to and differs from PixelHeight.

    Picture.CurHeightOffset (double)

        Used in the printing process; this indicates how far along vertically
	the printing process has gotten, so the printing mechanism can keep
	track of how much of the image has been printed at any one position in
	the page.

    Picture.TextOffset (double)

        The text-offset indicates how far text should be spaced from the 
	picture when the picture is in-flow or in flow-around mode.  In such
	a case the top-edge of the picture is aligned with the top-edge of the
	text in the current line, and the text-offset is used to space the 
	rest of the text horizontally and at the bottom from the picture.  If
	no text is present at the left or right side, the picture is placed
	flush against the margin without the offset.

    Picture.ColorMode (int)

        The color mode indicates how the data is formatted in the image.  The
	images are NEVER INDEXED, but rather all have direct greyscale or RGB
	values of one kind or another.  The following are the possible values
	for ColorMode:

	    PRT_IMG_BINARY (0)		The image uses one bit per pixel, and
	    				a 1 value indicates "on" or "white",
					where a 0 value indicates "black".
					Note that this may seem reversed for 
					some printers, which print black on
					white, but this is consistent with the
					other picture color modes.

	    PRT_IMG_GREY (1)		The image uses 8 bits per pixel, where
	    				255 is white and 0 is black.

	    PRT_IMG_LOWCOLOR (2)	The image uses 8 bits per pixel, only
	    				six of which are actually used.  Two
					bits are allocated each for the inten-
					sities of R, G, and B, in the format
					xxRRGGBB.

	    PRT_IMG_HIGHCOLOR (3)	The image uses 24 bits per pixel, with
	    				8 bits (one byte) allocated to the 
					intensity levels of R, G, and B, in the
					same manner as these colors are defined
					in HTML (0x00RRGGBB).

    Picture.DataLength (int)

        The number of bytes of image data present at Picture.Data.

    Picture.Flags (int)

	The only flag value currently defined is PRT_IMG_F_INFLOW, which 
	indicates that the picture is in-flow positioned rather than absolute
	positioned on the page (and thus its location can be changed by the
	way the text flows into the various sections, tables, and columns).

    Picture.Data (unsigned char*)

        A pointer to a memory region containing the raw image data.  For 1bpp
	images (PRT_IMG_BINARY), the leftmost bit is bit7 of the data, and the
	bits proceed across the first row of the image.  Furthermore, for 1bpp
	images, the rows are "rounded" off; that is, if the image is only 4
	pixels wide, each row still uses a full byte, but the last half (bits 3
	through 0) of the byte are not used.


LAYOUT OPERATIONS....

    This section of this design seeks to define how the various layout
    operations will be performed.  Many of these layout operations have been
    referred to or alluded to in the commands/structure section of this
    document.

    WordWrap

        This operation takes a line of text that has exceeded the specified
	maximum allowable length, and splits it into one line that fits within
	the length and a second line that contains the remainder of the
	original line.  The second line may have to be word-wrapped as well.

	This routine should take a pointer to the line to be wrapped, a pointer
	to the end of that line, and the x/y location of the target point for
	the text that did not fit (usually beginning of the next line, but if
	an image is in the middle of the text, it could be later on the same
	line).  This routine should also be passed the available width on the
	line.

	    - If the pointer to the end of the line is NULL, scan forward from
	      the start until an element is found whose start+width exceeds the
	      allowable width, or until no more elements are found.  That 
	      element is the "end of the line."
	    - Start at the end element of the line of text, and follow the Prev
	      pointers, until an element is found whose start point is within
	      the allowable line length.
	    - Then, search each element starting with the found one, following
	      Prev pointers as before, performing the following operations on
	      each one:
	        - Make a note of the first such element found.  It is the fall-
		  back hard-break word wrap element that will be used should no
		  appropriate break point be found elsewhere.
		- Search for a space or hyphen in the element such that the
		  print length of the string up to the space (or up to and 
		  including the hyphen) is less than or equal to the maximum
		  allowable line length.  If found, the search is finished.
		- Search for a non-alphanumeric character (except quote marks)
		  such that the print length of the string up to and including
		  the character (plus the start position of the element) is
		  less than or equal to the maximum allowable line length.  If
		  found, make a note of the element and position but do no more
		  yet.
	    - If a space/hyphen element was found, use it.  Otherwise, if a 
	      non-alphanumeric one was found, use it.  Otherwise, use the first
	      element noted in the search (see above).
	    - If the first element noted is being used, find the breaking point
	      in it -- search at the beginning of the string for the <n>
	      characters that would fit within the line, given the start 
	      position of the element.
	    - Make two elements from the one element, discarding all contiguous
	      space characters after the breaking point and before the breaking
	      point (including the breaking point if it is a space itself).
	    - If the first of the elements is empty, delete it.
	    - Place the first element at the end of the current line, and place
	      the second starting as a new line.
	    - Check justification on the original line.
	    - Check for automatic page-break.

    Justify

        This operation left, right, center, or full justifies a line of text on
	the line on the paper or screen so that the edges of the text match up
	with the margins as appropriate.

	These routines should take pointers to the start and end elements of
	the line to be justified, as well as the length of the area the items
	are to be justified within.

	    Left/Center/Right:

	    - Note the length of the line by checking the last item on the line
	      for start-x plus width, minus the start-x of the first item on
	      the line.
	    - Calculate a delta from the current line start-x (probably 0) to
	      the desired line start-x (depending on justification type).
	    - Add the delta to all start-x on the given line.

	    Full:

	    - If last element indicates PRT_OS_F_BREAK, skip justification.
	    - Go through the objstream elements in the line, and break them up
	      into smaller chunks by word, with the space character(s) left at
	      the beginning of elements (not at ends).
	    - Calculate the length of the line, and divide it by the number of
	      elements that start with space(s) (which is equal to the number
	      of words on the line, minus one).
	    - Add that calculated amount to the start-x of each 'word' that 
	      starts with a space, accumulating, so that for the nth element to
	      be modified, n*calc_value is added.

    PageBreak

        This layout operation performs a page break check and page break 
	operation.  The page break involves splitting the layout structure into
	two separate structures, with much of the overall structural data
	duplicated but the text and image data contained within those data
	structures split into two sections.

	    Check:

	    - Compare the end objstream element at the objstream pointer with
	      the available-height value of the parent element.  If the 
	      relativeY of the current element plus the current element's
	      height is greater than the available-height, then the current
	      element exceeds the page break point.  A page break is necessary.

	    PageBreak:

	    - Follow the path from the current objstream element up to the root
	      element, and duplicate that entire structure.
	      - Make sure the first element inside each section/table-cell is
	        an empty-string element containing the proper attributes as
		should be continued from the previous page.
	      - If the path includes a table, replicate the table headers as
	        well as the table and the current data.
	    - Trace from the current element back to include all elements that
	      exceed the available-height (specified in the Check: details
	      above), and *move* them to the duplicated structure.

    InsertHeader

        This layout function invokes the callback routines to generate a page
	header and insert it into the newly started page.

	    - Save the current element pointer, and set the current element
	      pointer to the top-level section for the page.
	    - Call the header functions, in given sequence, to generate the
	      headers. 
	      - Before each call, set the clip height on the page appropriately
	        to keep the header within its declared boundaries.
	      - After each header function, issue a newline, and begin the line
	        with an empty string element set to the top-level attributes of
		the page.
	    - Reset the clip height and current element pointer.

    InsertFooter

        This function invokes the callback routines to generate a page footer
	and insert it into the end of a recently-ended page.

	    - Save the current element pointer, and add an empty-string element
	      to the top-level section, setting the current element pointer
	      there.
	    - Adjust the page's available height to the whole page, footer area
	      included.
	    - Call the header functions, in given sequence, to generate the
	      headers. 
	      - Before each call, check to make sure the current element
	        pointer starts on a fresh line.
	      - Before each call, set the clip height on the page appropriately
	        to keep the footer within its declared boundaries.


IMAGE AND AREA LAYOUT FORMATTING....

    One of the more difficult aspects of performing a proper layout operation
    for the page is the problem of working around images and areas.  There are
    four basic situations with images or areas (referred to from now on just as
    an image) that influence how the layout operation works.

    1.  An in-flow image that becomes a part of the line of text it is on.

        Flags:  PRT_OS_F_INFLOW

	This type of image keeps its position in the line of text, and its
	height influences the height of the line of text.  The next line of
	text will be completely below the bottom of the image, and text will
	not wrap around the image.  This type of image formatting can be used
	for bullets, inline images, and images that reside on a line of their
	own.

	Formatting for this kind of image is simply done by adjusting the 
	height of the line, and thus the starting relative-Y of the next line.

    2.  An in-flow image that, while it starts on a given line, allows text to
        flow around it.

	Flags:  PRT_OS_F_INFLOW, PRT_OS_F_FLOWAROUND

	This type of image is logically connected to a position in the string
	of text, but it doesn't necessarily stay exactly in that position. 
	Instead, it positions its starting point on the same line as its 
	logical position in the text, but its starting X-position (left edge)
	is specified by the data for the image.  Thus, the image can be made
	to align with the right or left edge of the container in which it
	resides.

	Furthermore, with this type of image, the text can "flow around" the
	image as well.  That is, subsequent lines of text below the line which
	the image is connected with will not necessarily be below the image
	(unless the image is shorter than one line of text), but will rather
	continue with line spacing as has been specified by the text elements.

	These issues essentially mean that the text will have to be wrapped at,
	and justified to, points that are well inside the container's margins.
	Furthermore, if the image is in the middle of a container, each line of
	text may be split into two pieces, each of which will be independently
	wrapped and justified.

    3.  An absolutely-positioned image that is located at a given X and Y
        within its container.

	Flags:  <none>

	This type of image simply "floats above" the container that it is in.
	No text-wrapping is performed to "avoid" the image; it is simply
	positioned at a location and that is where it prints.

	Formatting for this kind of image is straightforward - it is inserted
	into the container's objectstream and is printed at its given X/Y.

    4.  An absolutely-positioned image that affects the flow of the text
        beneath it.

	Flags:  PRT_OS_F_FLOWAROUND

	This type of absolutely positioned image is not linked to a particular
	line of text like a type-2 (see above) image is, but it does affect the
	wrapping of the text "beneath" it just like a type-2 image does.

	Formatting is identical to a type-2 image after both types of images
	have been positioned.
   

LAYOUT FORMATTING FOR A MULTICOLUMN SECTION....

    Multicolumn section layout has to be done in a slightly different manner 
    from the standard single-column sections, table cells, and areas.  These
    sections need to have column-top-pointers updated whenever the height or
    Y position of any element is changed in the section, or whenever a new
    line is begun within a section.

-------------------------------------------------------------------------------
